# SNHU-CS-340

## How do you write programs that are maintainable, readable, and adaptable? Especially consider your work on the CRUD Python module from Project One, which you used to connect the dashboard widgets to the database in Project Two. What were the advantages of working in this way? How else could you use this CRUD Python module in the future?

I write programs that are maintainable, readable, and adaptable by following code writing best practices. This includes writing descriptive comments, maintaining a proper code architecture and using the proper programming patterns where necessary. One example of maintaining a proper code architecture is the architecture of this project. It is distinctly split into 3 layers: the MongoDB database, the CRUD API and the Dashboard. By keeping these components seperate I was able to avoid spaghetti code and in particular the CRUD API simplified operations on the database by the Dashboard by adding a layer of abstraction above the PyMongo API.

## How do you approach a problem as a computer scientist? Consider how you approached the database or dashboard requirements that Grazioso Salvare requested. How did your approach to this project differ from previous assignments in other courses? What techniques or strategies would you use in the future to create databases to meet other client requests?

In contrast to assignments in previous courses, I used the Waterfall method to approach this problem as opposed to an Agile methodology. I did so because the project requirements were well defined beforehand which allowed me to skip the requirements gathering phase and skip straight to the design phase. However, the requirements will not always be as well defined, and as such I will likely also use the Agile methodology to creating databases in the future.

## What do computer scientists do, and why does it matter? How would your work on this type of project help a company, like Grazioso Salvare, to do their work better?

Computer Scientists at their core are problem solvers. They take a clients request and break it into its constituent parts. They then use the tools available to them to solve the problem, and do so in such a way that these components created can be reused and solving a problem with similar requirements in the future will be easier. That last bit is very important because every tool a modern computer scientist uses was probably created by a past computer scientist that encountered a similar problem. These tools of solved problems all work together and add to the collective toolset of computer scientists as a whole and allow familar problems be solved faster and even more complex problems to be solved for the first time. This process feeds into itself like a feedback loop or an avalanche.
